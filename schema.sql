--Metadata to go along with the vehicle imgs in the data store
CREATE TABLE public."vehicle-photos" (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT UNIQUE, -- file name from storage
  status TEXT DEFAULT 'unprocessed', 
  created_at TIMESTAMPTZ DEFAULT NOW(),
  company_id INTEGER DEFAULT NULL,
  CONSTRAINT fk_company
    FOREIGN KEY (company_id) REFERENCES "vehicle-photos"(id)
    ON DELETE SET NULL

);

--Companies
CREATE TABLE companies (
 id SERIAL PRIMARY KEY,
 name TEXT NOT NULL,
 industry TEXT[] DEFAULT '{}',
 primary_email TEXT DEFAULT '',
 email TEXT[] DEFAULT '{}',
 primary_phone TEXT DEFAULT '',
 phone TEXT[] DEFAULT '{}',
 city TEXT DEFAULT '',
 state TEXT DEFAULT '',
 created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
 updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

--Create metadata entry upon inserting to vehicle img store
CREATE OR REPLACE FUNCTION public.insertimg()
RETURNS trigger
LANGUAGE plpgsql
SECURITY INVOKER
SET search_path = public, pg_catalog AS $$
begin
  INSERT INTO public."vehicle-photos" (name)
  VALUES (NEW.name);
  RETURN NEW;
END;
$$;

--Register insertimg() to fire when object is inserted
CREATE TRIGGER on_new_image
AFTER INSERT ON storage.objects
FOR EACH ROW
WHEN (NEW.bucket_id = 'gh-vehicle-photos') 
EXECUTE PROCEDURE public.insertimg();

-- Enable and create pgmq
CREATE extension IF NOT EXISTS pgmq CASCADE;
SELECT pgmq.create('image-processing');

-- Creates or replaces a function to upsert a company's details.
-- This version adds functionality to accept and append an array of industry.
--
-- @param p_name The name of the company to upsert.
-- @param p_email The new email to add to the company's email list.
-- @param p_phone The new phone number to add to the company's phone list.
-- @param p_industry An array of industry to be added to the company.
--
-- Note: Assumes "emails", "phone", and "industry" columns are TEXT arrays (TEXT[]).

CREATE OR REPLACE FUNCTION public.upsert_company(p_name TEXT, p_email TEXT, p_phone TEXT, p_industry TEXT[], p_city TEXT, p_state TEXT)
RETURNS VOID AS $$
DECLARE
    v_company_id UUID;
BEGIN
    -- Check if a company with the given name already exists.
    SELECT id INTO v_company_id FROM public.companies WHERE name = p_name;

    IF v_company_id IS NOT NULL THEN
        -- Company exists, so update it.
        UPDATE public.companies
        SET
            email = CASE
                WHEN p_email IS NULL OR p_email = ANY(email) THEN email
                ELSE array_append(email, p_email)
            END,
            "phone" = CASE
                WHEN p_phone IS NULL OR p_phone = ANY("phone") THEN "phone"
                ELSE array_append("phone", p_phone)
            END,
            -- To merge arrays and remove duplicates, we unnest the combined array,
            -- select distinct values, and then aggregate them back into a new array.
            industry = (
                SELECT array_agg(DISTINCT T.industry)
                FROM unnest(industry || p_industry) AS T(industry)
            ),
            city = CASE
                WHEN p_city IS NULL OR p_city = ANY(city) THEN city
                ELSE array_append(city, p_city)
            END,
            state = CASE
                WHEN p_state IS NULL OR p_state = ANY(state) THEN state
                ELSE array_append(state, p_state)
            END
        WHERE id = v_company_id;
    ELSE
        -- Company does not exist, so insert a new one.
        INSERT INTO public.companies (name, email, "phone", industry, city, state)
        VALUES (p_name, ARRAY[p_email], ARRAY[p_phone], p_industry, ARRAY[p_city], ARRAY[p_state]);
    END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = public;ASE
                WHEN p_phone IS NULL OR p_phone = ANY(phones) THEN phones
                ELSE array_append(phones, p_phone)
            END
        WHERE id = v_company_id;
    ELSE
        -- Company does not exist, so insert a new one.
        -- The email and phone are placed into new arrays.
        INSERT INTO companies (name, emails, phones)
        VALUES (p_name, ARRAY[p_email], ARRAY[p_phone]);
    END IF;
END;
$$ LANGUAGE plpgsql;
